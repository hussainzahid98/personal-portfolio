{"status":"ok","feed":{"url":"https://medium.com/feed/@@hussainzahidgiki","title":"Stories by Hussain Zahid on Medium","link":"https://medium.com/@hussainzahidgiki?source=rss-cd241c0b7568------2","author":"","description":"Stories by Hussain Zahid on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*HQ9pJrkgMq0ol4mUDGkmTg.jpeg"},"items":[{"title":"What is the event-driven, non-blocking I/O model of Node.js?","pubDate":"2023-02-14 15:35:06","link":"https://medium.com/@hussainzahidgiki/what-is-the-event-driven-non-blocking-i-o-model-of-node-js-84fb41db3cba?source=rss-cd241c0b7568------2","guid":"https://medium.com/p/84fb41db3cba","author":"Hussain Zahid","thumbnail":"https://cdn-images-1.medium.com/max/600/0*i-4BCjhyyF5zfjfJ.png","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/0*i-4BCjhyyF5zfjfJ.png\"></figure><p>Node.js is a popular platform for building server-side applications and has gained widespread adoption in recent years. Two main reasons for\u00a0that:</p>\n<ul>\n<li>It is lightweight owing to the single-threaded architecture instead of the multithreaded architecture usually found in frameworks like\u00a0PHP.</li>\n<li>It is fast because of its event-driven and nonblocking I/O\u00a0model.</li>\n</ul>\n<p>But what do these terms even mean? Before we dive into Node\u2019s architecture let\u2019s first look at what blocking or synchronous code is. The code snippet below represents synchronous code:</p>\n<pre>console.log('First Line ');<br>console.log('Second Line ');<br>console.log('Third Line ');</pre>\n<p>If we run this program we\u00a0get:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/768/1*5R9iejhpWsWmjnFe8R2mdg.png\"></figure><p>As you can tell from the output, blocking code is executed line by line. Until the first line has not finished executing, it will not proceed. This means that if we write blocking code like this in a web app, because Node is single-threaded ( a thread is just a set of instructions), each user that tries to access our app will have to wait for the program to complete execution for the previous\u00a0user.</p>\n<p>Now, for just a few users this might not be a problem but when you are dealing with thousands of users at the same time this can turn ugly very quickly. Enter, the event loop. The event loop is what allows Node to have asynchronous or non-blocking abilities despite it being single-threaded, more on this in a\u00a0bit.</p>\n<p>It\u2019s important to note that Node is built around the concept of callbacks. Callbacks make sure that a function is not going to run before a task is completed but will run right after the task has been completed. Below is a familiar callback we use while dealing with HTTP requests:</p>\n<pre>const express = require(\"express\");<br><br>const app = express();<br><br>app.get(\"/\", (req, res) =&gt; {<br>  res.send(\"hello\");<br>});<br><br>app.listen(8080);</pre>\n<p>The event loop as the name suggests is a loop that runs cycle after cycle until there are no events in the loop. It receives events and calls the callbacks associated with those\u00a0events.</p>\n<p>Consider the above example, when we start the application with the above code, the event loop is initialized and the callback function containing the response is stored in what\u2019s called a callback queue. As soon as a user hits the endpoint, an event will be emitted and the event loop will call the associated callback function, in our case sending a hello response.</p>\n<p>Now, at any given time there could be numerous events so the event loop executes the callbacks in a defined order as shown\u00a0below:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/486/0*z2BU1_SYj-MCiosx.png\"></figure><p>The different categories of callbacks is a topic for another day but most of our code in Node is gonna lie in the second\u00a0one.</p>\n<p>To Conclude, the high performance of Node despite being single threaded is only possible due to the asynchronous abilities that the event loop lends it. This event orchestration and the asynchronous nature is what\u2019s referred to as an \u201cevent-driven, non-blocking I/O model\u201d of\u00a0Node.js.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=84fb41db3cba\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/0*i-4BCjhyyF5zfjfJ.png\"></figure><p>Node.js is a popular platform for building server-side applications and has gained widespread adoption in recent years. Two main reasons for\u00a0that:</p>\n<ul>\n<li>It is lightweight owing to the single-threaded architecture instead of the multithreaded architecture usually found in frameworks like\u00a0PHP.</li>\n<li>It is fast because of its event-driven and nonblocking I/O\u00a0model.</li>\n</ul>\n<p>But what do these terms even mean? Before we dive into Node\u2019s architecture let\u2019s first look at what blocking or synchronous code is. The code snippet below represents synchronous code:</p>\n<pre>console.log('First Line ');<br>console.log('Second Line ');<br>console.log('Third Line ');</pre>\n<p>If we run this program we\u00a0get:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/768/1*5R9iejhpWsWmjnFe8R2mdg.png\"></figure><p>As you can tell from the output, blocking code is executed line by line. Until the first line has not finished executing, it will not proceed. This means that if we write blocking code like this in a web app, because Node is single-threaded ( a thread is just a set of instructions), each user that tries to access our app will have to wait for the program to complete execution for the previous\u00a0user.</p>\n<p>Now, for just a few users this might not be a problem but when you are dealing with thousands of users at the same time this can turn ugly very quickly. Enter, the event loop. The event loop is what allows Node to have asynchronous or non-blocking abilities despite it being single-threaded, more on this in a\u00a0bit.</p>\n<p>It\u2019s important to note that Node is built around the concept of callbacks. Callbacks make sure that a function is not going to run before a task is completed but will run right after the task has been completed. Below is a familiar callback we use while dealing with HTTP requests:</p>\n<pre>const express = require(\"express\");<br><br>const app = express();<br><br>app.get(\"/\", (req, res) =&gt; {<br>  res.send(\"hello\");<br>});<br><br>app.listen(8080);</pre>\n<p>The event loop as the name suggests is a loop that runs cycle after cycle until there are no events in the loop. It receives events and calls the callbacks associated with those\u00a0events.</p>\n<p>Consider the above example, when we start the application with the above code, the event loop is initialized and the callback function containing the response is stored in what\u2019s called a callback queue. As soon as a user hits the endpoint, an event will be emitted and the event loop will call the associated callback function, in our case sending a hello response.</p>\n<p>Now, at any given time there could be numerous events so the event loop executes the callbacks in a defined order as shown\u00a0below:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/486/0*z2BU1_SYj-MCiosx.png\"></figure><p>The different categories of callbacks is a topic for another day but most of our code in Node is gonna lie in the second\u00a0one.</p>\n<p>To Conclude, the high performance of Node despite being single threaded is only possible due to the asynchronous abilities that the event loop lends it. This event orchestration and the asynchronous nature is what\u2019s referred to as an \u201cevent-driven, non-blocking I/O model\u201d of\u00a0Node.js.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=84fb41db3cba\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["backend-development","api","javascript","software-development","nodejs"]}]}